import { RawCoordinator, StoreType } from 'dataspray-runner';
{{^processor.jsonOutputStreams.empty}}
import {
{{#processor.jsonOutputStreams}}
    {{{dataFormat.nameCamelUpper}}},
{{/processor.jsonOutputStreams}}
} from './streams';
{{/processor.jsonOutputStreams.empty}}

export interface Coordinator {
    {{#processor.hasDynamoState}}

    /**
     * State management backed by DynamoDB and unique for each message key within a task.
     * <p>
     * Identical to calling {@link #stateForNamespace}{@code (ttl, "task", <task_name>, "key", <message_key>)}.
     * Each state has a combined limit of 1MB. Writes are buffered and flushed after each message batch.
     * @param ttlInSec Optional second-precision time-to-live for the state. Resets on every write.
     */
    stateForMessageKey(ttlInSec?: number): StateManager;

    /**
     * State management backed by DynamoDB and unique for entire task.
     * <p>
     * Identical to calling {@link #stateForNamespace}{@code (ttl, "task", <task_name>)}.
     * Each state has a combined limit of 1MB. Writes are buffered and flushed after each message batch.
     * @param ttlInSec Optional second-precision time-to-live for the state. Resets on every write.
     */
    stateForTask(ttlInSec?: number): StateManager;

    /**
     * State management backed by DynamoDB with custom namespace.
     * <p>
     * Each state has a combined limit of 1MB. Writes are buffered and flushed after each message batch.
     * @param namespace Unique key for the state.
     * @param ttlInSec Optional second-precision time-to-live for the state. Resets on every write.
     */
    stateForNamespace(ttlInSec: number | undefined, namespace: string[]): StateManager;
    {{/processor.hasDynamoState}}
    {{#processor.outputStreams}}

    /**
     * Sends a message to {{{storeName}}} {{{streamName}}}.
     *
     * @param messageKey Entity of the message used for partitioning (e.g. Session ID, Email, IP address)
     * @param {{{dataFormat.nameCamelLower}}} Content of the message
     * @param messageId Optional unique ID of the message used for de-duplication (e.g. Transaction ID)
     */
    sendTo{{{uniqueNameCamelUpper}}}(messageKey: string, {{{dataFormat.nameCamelLower}}}: {{{dataFormat.nameCamelUpper}}}, messageId?: string): void;
    {{/processor.outputStreams}}
}

export class CoordinatorImpl implements Coordinator {

    private rawCoordinator: RawCoordinator;
    {{#processor.hasDynamoState}}
    private messageKey: string;
    {{/processor.hasDynamoState}}

    constructor(
        rawCoordinator: RawCoordinator,
        {{#processor.hasDynamoState}}
        messageKey: string,
        {{/processor.hasDynamoState}}
    ) {
        this.rawCoordinator = rawCoordinator;
        {{#processor.hasDynamoState}}
        this.messageKey = messageKey;
        {{/processor.hasDynamoState}}
    }
    {{#processor.hasDynamoState}}

    stateForMessageKey(ttlInSec?: number): StateManager {
        return this.stateForNamespace(ttlInSec, ["task", "{{{processor.taskId}}}", "key", this.messageKey]);
    }

    stateForTask(ttlInSec?: number): StateManager {
        return this.stateForNamespace(ttlInSec, ["task", "{{{processor.taskId}}}"]);
    }

    stateForNamespace(ttlInSec: number | undefined, namespace: string[]): StateManager {
        return this.rawCoordinator.getStateManager(namespace, ttlInSec);
    }
    {{/processor.hasDynamoState}}
    {{#processor.outputStreams}}

    sendTo{{{uniqueNameCamelUpper}}}(messageKey: string, {{{dataFormat.nameCamelLower}}}: {{{dataFormat.nameCamelUpper}}}, messageId?: string): void {
        this.rawCoordinator.send(
            messageKey,
            {{#dataFormat.isSerdeString}}
            new Blob([{{{dataFormat.nameCamelLower}}}], { type: 'plain/text' }),
            {{/dataFormat.isSerdeString}}
            {{#dataFormat.isSerdeJson}}
            new Blob([JSON.stringify({{{dataFormat.nameCamelLower}}}, null, 2)], { type: 'application/json' }),
            {{/dataFormat.isSerdeJson}}
            StoreType.{{{storeType.name}}},
            "{{{storeName}}}",
            "{{{streamName}}}",
            messageId);
    }
    {{/processor.outputStreams}}
}
